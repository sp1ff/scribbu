\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename scribbu.info
@settitle scribbu
@c %**end of header
@copying

Copyright @copyright{} 2018-2019 Michael Herstine <sp1ff@@pobox.com>

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled ``GNU
Free Documentation License''.

A copy of the license is also available from the Free Software
Foundation Web site at @url{https://www.gnu.org/licenses/fdl.html}.

@end quotation

This document was typeset with
@uref{http://www.texinfo.org/, GNU Texinfo}.

@end copying

@titlepage
@title scribbu
@subtitle The extensible tool for tagging your music collection
@author @email{sp1ff@@pobox.com}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Output the table of the contents at the beginning.
@contents

@ifnottex
@node Top
@top scribbu

The extensible tool for tagging your music collection.

This manual corresponds to scribbu version 0.5.

@insertcopying

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* Introduction::
* The @command{scribbu} Program::
* Scripting @command{scribbu}::
* Using @code{libscribbu}::
* Frame Identifiers::
* Character Encodings::
* Index::
@end menu

@c If I don't include the menu in the ifnottex block, texinfo
@c complains when I generate pdf...
@end ifnottex

@c Update all node entries with `C-c C-u C-n'.
@c Insert new nodes with `C-c C-c n'.
@node Introduction
@chapter Introduction
@cindex Introduction

scribbu is a C++ library & associated command-line tool for working
with ID3 tags (@xref{ID3}.) It was born when I retired my last Windows
machine & could no longer use Winamp (@xref{Winamp}.) to manage my
library of digital music. The scribbu library offers classes & methods
for reading, modifying & writing ID3v1 & ID3v2 tags. The scribbu
program provides assorted sub-commands for working with ID3-tagged
files (e.g. re-naming files based on their tags), but its real power
lies in its embedded Scheme interpreter (@xref{Top,,, Guile, The Guile
Reference Manual}.) in which scribbu library features are exported as a
Scheme module (on which more below).

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* scribbu::
* Project Background::
@end menu

@node scribbu
@section scribbu
@cindex scribbu

The scribbu project has a few components. The first is a program that
provides assorted sub-commands, a few of which are:

@enumerate

@item
@command{scribbu dump} @xref{Invoking @command{scribbu dump}}. will write
the contents of any & all ID3 tags found in one or more files to
stdout.

@item
@command{scribbu report} @xref{Invoking @command{scribbu
report}}. will generate a report listing ID3 attributes on one or more
files on stdout.  CSV, TDF & ASCII-delimited formats are supported
currently.

@item
@command{scribbu rename} @xref{Invoking @command{scribbu
rename}}. will rename one or more files based on the contents of their
ID3 tags; e.g. @command{scribbu rename -t ``%A-%T.mp3'' *.mp3} will rename
all the files matching ``*.mp3'' to ``<artist>-<title>.mp3'' where
"artist" and "title" are derived from their ID3 tags (if any).

@item
@command{scribbu popm} @xref{Invoking @command{scribbu popm}}. will
update ID3v2 play count & popularimeter tags. For instance,
@command{scribbu popm foo.mp3} will increment the play counts in
``foo.mp3''.

@item
@command{scribbu text} @xref{Invoking @command{scribbu text}}.
maintains assorted ID3v2 text frames; for instance, @command{scribbu
text --artist='Roxy Music' *.mp3} will set the artist frame to ``Roxy
Music'' in all ID3v2 tags in all files matching ``*.mp3''.

@end enumerate

Any sub-command can be invoked with @option{--help} or @option{-h} for
more information. Use @option{--info} option to display the command's
node in this manual.

The @command{scribbu} program also exports functions & GOOPS
@xref{Top,,, Guile, GOOPS}. classes to a Scheme interpreter, so
@command{scribbu} can @emph{also} be invoked...

@enumerate

@item
with a Scheme expression (@option{-e}, @option{--expression}) or
Scheme file (@option{-f}, @option{--file}).  In this case, scribbu
will evaluate the given program & exit.

@item
with no arguments at all. In this case, scribbu will drop into a
Scheme REPL (Read Evaluate Print Loop) in which the user can evaluate
arbitrary Scheme expressions.

@item
as a script:

@lisp
#!/usr/local/scribbu \
-e main -s
#!
(define (main args)
    ...
@end lisp

@end enumerate

Finally, scribbu contains a C++ library (@code{libscribbu})
@xref{Using @code{libscribbu}}. against which one can build C++
libraries & programs.


@node Project Background
@section Project Background

Some background on MP3, ID3, Winamp & the genesis of this project.

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* MP3::
* ID3::
* Winamp::
* Today::
@end menu

@node MP3
@subsection MP3

Widespread digital encoding of music arrived with the introduction of
the compact disk in 1982. However, the size of the resulting digital
representation was large: the standard Compact Disk stored about one
hour & twenty minutes worth of music in about seven hundred MiB (at a
time when the typical hard drive could hold ten MiB). In 1989 the
relevant standards body (the Moving Picture Experts Group, or MPEG)
called for proposals for lossy audio compression algorithms. The
fourteen propsals they received were eventually combined into three
``layers'', each with a different set of trade-offs between quality,
space, and computational complexity. ``MPEG Audio Layer I'' was the
simplest, designed to enable real-time encoding on the hardware of the
day. ``MPEG Audio Layer II'' provides higher quality than Layer I but
offers computationally simpler decoding than Layer III.  ``MPEG Audio
Layer III'' (or @dfn{MP3}) provides good quality at lower bitrates
than Layer II, albeit at the cost of greater computational complexity.

Layer three was primarily developed by the German company Fraunhofer
IIS. The file extension @code{.mp3} was selected as a result of an
internal survey of researchers at Frauhofer. At a sampling rate of
128kbits/sec, MP3 needed about a megabyte per minute of music encoded;
nearly one-tenth the size of CD audio.

At one MB per minute, given the size of consumer hard drives in the
nineties, home users could easily store many MP3 tracks. The format
found such universal application in the portable digital music players
becoming available that they came to be known as ``mp3 players''. With
the network bandwidths available at the time, one could conveniently
transmit MP3-encoded files across the internet, and even stream them.

Typically of technological history, the application responsible for
the widespread adoption of MP3 was not the application for which it
was designed.  Applications for audio encoded by MP3 were intitially
thought to be ``musical transmission over ISDN telephone lines'' and
``voice announcement systems for local public transport''. Instead,
the medium of choice for digital music became the `.mp3' file.


@node ID3
@subsection ID3

A problem quickly emerged: the MP3 standard included no provision for
metadata; no way to ``tag'' an @code{.mp3} file with information such
as title, artist, et cetera. NamkraD (AKA Eric Kemp) is credited with
the idea of attaching such a tag to @code{.mp3} files in
1996. Presumably to make it easy to detect & parse, while not
interfering with existing decoders, it had a fixed size of one hundred
twenty-eight bytes, and was attached to the end of the file (if a
player that was unaware of the tag played the enclosing file, at worst
the user would hear a bit of static at the end). It provided for a
thirty-byte title, artist & album along with year, comment & a
one-byte genre field. The original proposal defined eighty genres,
extended to 148 by 1.91 release of Winamp (@xref{Winamp}.) in June 1998
and to 192 by the 5.6 release of Winamp in November 2010.

The limitations of this format quickly became aparent, leading to the
proposal in 1998 of ID3v2 by Martin Nilsson and several other
contributors. Although it shared a name, ID3v2 was a completely
different approach to tagging music: it was prepended to the audio
data (making it suitable for streaming media) and it was
variable-length; ID3v2 tags are comprised of multiple frames, each
containing one piece of information about the music (title, artist
&c).


@node Winamp
@subsection Winamp

Space-efficient, high-quality, tagged audio was no good without a
ready means of listening to it. The then-existing Windows Media Player
and Real Networks' Real Player never found widespread adoption. In
April 1997 Justin Frankel and Dmitry Boldyrev released Winamp, a
small, performant Windows MP3 player. Frankel formed Nullsoft in
January 1998. With version 1.5, Winamp changed from freeware to
shareware & charged a ten dollar registration fee; far from dampening
uptake, this brought in $100,000 a month from $10 paper checks in the
mail from paying users. Winamp 2.0 was released in September 1998 &
became one of the most downloaded Windows programs ever.

One of the things that endeared Winamp to its users was its plugin
architecture. Nullsoft provided several plugins as part of the standard
distribution, one of which was the Music Library. Using this, one
could manage, organize, search & play a personal library of thousands
of MP3 files, all based on ID3 tags (@xref{ID3}.)

Nullsoft was (in)famoulsy acquired by AOL in 1999. By 2000 Winamp had
been registered twenty-five million times, but Nullsoft began to
struggle with the propblems of so many AOL acquisitions. 2002 saw the
misbegotten release of Winamp 3, a complete re-write that broke with
the prior ethos of tight, lightweight code. Widespread incidence of
users (including the author) reverting to Winamp 2 in response to poor
performance & high resource demands of Winamp 3 led to Nullsoft
continuing 2.x development, and eventually the release of Winamp 5
(2+3) late in 2003. From version 5.2, Winamp provided the ability to
sync the user's library with iPods, which led to many iPod owners'
(again including the author) choosing to use Winamp instead of iTunes
to manage their devices.

The original Winamp team quit AOL in 2004 & development moved to
Dulles (VA).  Work continued, albeit at a slower pace. With the
release of Winamp 5.66 in late 2013, AOL announced that winamp.com
would be shutdown later that year and that the software would no
longer be availble for download. It was later announced that Nullsoft
(along with Shoutcast, an MP3 streaming platform) had been sold to the
Belgian company Radionomy. As of the time of this writing, winamp.com
is up, and offering a download of Winamp 5.8 (beta) from Radionomy.


@node Today
@subsection Today

It is a credit to Winamp that it remained usable well into the
twenty-teens as a way to mange large libraries of @code{.mp3}
files. Winamp is not quite dead, but it is stranded on an operating
system that I have left behind (along, I suspect, with many other
technically-inclined music aficionados today). The MP3 format itself
is showing its age; Fraunhofer IIS announced in 2017 that it was
ending its licensing programs for MP3. AAC is now the standard for
digital music.

And yet, I have several thousand @code{.mp3} files in my personal
library. Since both MP3 and AAC are lossy formats, transcoding them to
AAC would not lead to good results even if I were inclined to do the
work. The original sources of many of the @code{.mp3s} have been lost,
so re-encoding to AAC is not possible.

Perhaps @command{scribbu} (@xref{The @command{scribbu} Program}.) will
support AAC in the future, but it seems that MP3 & ID3 will be
relevant to @emph{my} musical life for some time. I wrote this tool to
help me manage them, and I offer it to anyone else in the same
position: if you need to manage ID3-tagged @code{.mp3} files, and
especially if you enjoy hacking in LISP and/or C++, I hope you find
@command{scribbu} useful and enjoyable.


@node The @command{scribbu} Program
@chapter The @command{scribbu} Program
@cindex The @command{scribbu} Program

The simplest way to use scribbu is through the command-line tool. For
the @command{scribbu} command itself, as well as all @command{scribbu}
subcommands, the @option{-h} flag will produce a brief help message on
@code{stdout}, and the @option{--help} will display the corresponding
man page. You can get a list of all the sub-commands @command{scribbu}
provides by saying @command{scribbu -h}. You can display a given
sub-command's node in this Info manual by saying @command{scribbu CMD
--info}.

Display this manual by saying @code{scribbu --info}.

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* Example::
* Invoking @command{scribbu dump}::
* Invoking @command{scribbu report}::
* Invoking @command{scribbu rename}::
* Invoking @command{scribbu popm}::
* Invoking @command{scribbu text}::
@end menu

@node Example
@section Example

Let us suppose we have a few `.mp3' files which we have just
downloaded, or have encoded some time ago & forgotten
about. Regardless, we want to examine & update their tags before
adding them to our library. The following chapters demonstrate this
using @command{scribbu} sub-commands.

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* scribbu dump::
* scribbu report::
* scribbu popm::
* scribbu rename::
@end menu

@node scribbu dump
@subsection scribbu dump

The simplest place to start is @command{scribbu dump}. This will show
us what is in the tags:

@example
$>: scribbu dump *.mp3
"lorca.mp3":
ID3v2.3(.0) Tag:
452951 bytes, synchronised
flags: 0x00
The Pogues - Lorca's Novena
Hell's Ditch [Expanded] (US Version) (track 5), 1990
Content-type Pop
TIT2: Lorca's Novena
TPE1: The Pogues
TALB: Hell's Ditch [Expanded] (US Version)
TCON: Pop
TCOM: 
TPE3:
TRCK: 5
TYER: 1990
TPE2: The Pogues
COMM (<no description>):
Amazon.com Song ID: 203558254
TCOP: 2004 Warner Music UK Ltd.
TPOS: 1
frame APIC (115554 bytes)
frame PRIV (1122 bytes)
335921 bytes of padding
9425708 bytes of track data:
MD5: 48ff9cadea7d842e9059db25159d2daa
ID3v1.1: The Pogues - Lorca's Novena
Hell's Ditch [Expanded] (US Ve (track 5), 1990
Amazon.com Song ID: 20355825
unknown genre 255

"opium.mp3":
ID3v2.3(.0) Tag:
2038 bytes, synchronised
flags: 0x00
Stephan Luke - Opium Chant Intro
Opium Gardens (track 1), 2003
Content-type General Club Dance
Encoded by Winamp 5.552
TENC: Winamp 5.552
TRCK: 1
COMM (<no description>):
Ripped by Winamp on Pimpernel
TPUB: Opium Music
TPOS: 1/1
TYER: 2003 
TCON: General Club Dance
TALB: Opium Gardens
TPE2: Opium Garden
TPE1: Stephan Luke
UFID: http://www.cddb.com/id3/taginfo1.html
      334344334e33395235383037313937335532343836364232394336314239364139333341424332363945364531454642444233445032
TIT2: Opium Chant Intro 
1522 bytes of padding
1191874 bytes of track data:
MD5: 690194f49592c7d8ccfbfe8a157d4c1e
ID3v1.1: Stephan Luke - Opium Chant Intro
Opium Gardens (track 1), 2003
Ripped by Winamp on Pimperne
unknown genre 255

"orlando.mp3":
ID3v2.3(.0) Tag:
607 bytes, synchronised
flags: 0x40 
Bill LeFaive - Orlando
http://music.download.com (track 1), <no year>
TALB: http://music.download.com
TIT2: Orlando
TIT3: http://music.download.com/
TPE1: Bill LeFaive
TCOM: Bill LeFaive
frame WOAF (1 bytes)
frame WPUB (27 bytes)
frame WXXX (54 bytes)
TRCK: 1
TCOP: 2006 Bill LeFaive
TPUB: http://music.download.com
256 bytes of padding
6549838 bytes of track data:
MD5: dd0c70e13d4aeec676f8d7a7bda622b0
ID3v1.1: Bill LeFaive - Orlando
http://music.download.com (track 1), 2004
http://music.download.com/
unknown genre 255
@end example

We see we have three files, all of which have both ID3v1 & ID3v2 tags.
The output also contains some basic information on the MP3 data in
between the tags. 

@command{scribbu dump} takes as arguments one or more files and/or
directories, and prints information about all files listed, or in the
directories named, recursively. With no options, @command{scribbu
dump} will dump everything it understands. With options, the output
can be scoped in various ways (e.g. ID3v2 tags only, ID3v1 tags only,
track data only, among other options; refer to the man page for a
complete list (or @xref{Invoking @command{scribbu dump}}.))

@node scribbu report
@subsection scribbu report

Another way to investigate files, especially large numbers of files,
is @command{scribbu report}:

@example
$>: scribbu report -o myfiles.csv *.mp3
$>: cat myfiles.csv
directory,file,file size(MB),ID3v2 version,ID3v2 revision,ID3v2 size(bytes),ID3v2 flags,ID3v2 unsync,ID3v2 Artist,ID3v2 Title,ID3v2 Album,ID3v2 Content Type,ID3v2 Encoded By,ID3v2 Year,ID3v2 Langauges,# ID3v2 play count frames,Play Count,# ID3v2 comment frames,comment #0 text,comment #1 text,comment #2 text,comment #3 text,comment #4 text,comment #5 text,size (bytes),MD5,has ID3v1.1,has ID3v1 extended,ID3v1 Artist,ID3v1 Title,ID3v1 Album,ID3v1 Year,ID3v1 Comment,ID3v1 Genrre
"/tmp/tut","lorca.mp3",9.421,3,0,452951,0x00,0,The Pogues,Lorca's Novena,Hell's Ditch [Expanded] (US Version),Pop,,1990,,0,,1,Amazon.com Song ID: 203558254,,,,,,9425708,48ff9cadea7d842e9059db25159d2daa,1,0,The Pogues,Lorca's Novena,Hell's Ditch [Expanded] (US Ve,1990,Amazon.com Song ID: 20355825,255
"/tmp/tut","opium.mp3",1.139,3,0,2038,0x00,0,Stephan Luke,Opium Chant Intro,Opium Gardens,General Club Dance,Winamp 5.552,2003,,0,,1,Ripped by Winamp on Pimpernel,,,,,,1191874,690194f49592c7d8ccfbfe8a157d4c1e,1,0,Stephan Luke,Opium Chant Intro,Opium Gardens,2003,Ripped by Winamp on Pimperne,255
"/tmp/tut","orlando.mp3",6.247,3,0,607,0x40,0,Bill LeFaive,Orlando,http://music.download.com,,,,,0,,0,,,,,,,6549838,dd0c70e13d4aeec676f8d7a7bda622b0,1,0,Bill LeFaive,Orlando,http://music.download.com,2004,http://music.download.com/,255
@end example

Running @command{scribbu report} (@xref{Invoking @command{scribbu
report}}.) with an option of @option{-o <name>.csv} will produce an
RFC-4180-compliant comma separated variable file reporting on the
files given on the command line. Option @option{-t} will instead
produce tab-delimited data. @command{scribbu} itself provides little
beyond this in terms of reporting, the idea being that CSV or TDF
output can be readily imported into other programs better suited to
that task.

That said, one can do some basic querying at the command line, for
which tab-delimited format can be convenient. For example, this
little @command{awk} program will show the ID3v2 version for 
each file:

@example
$>: scribbu report -t -o myfiles.tdf *.mp3
$>: cat myfiles.tdf | awk 'BEGIN @{FS="\t"@}; @{print $2, $4@}'
file ID3v2 version
"lorca.mp3" 3
"opium.mp3" 3
"orlando.mp3" 3
@end example

@node scribbu popm
@subsection scribbu popm

We notice that none of these files contain a @code{PCNT} or
a @code{POPM} frame; let's add them now:

@example
$>: scribbu popm -a -o foo@@bar.com -r oooo *.mp3 
$>: scribbu dump *.mp3
...
PCNT: 0
POPM: foo@@bar.com
rating: 179
counter: 00
...
@end example

The @code{popm} command can be used to manage both PCNT & POPM frames
(@xref{Invoking @command{scribbu popm}}.) The @option{-a} flag
indicates that we want to create the relevant frames, if they don't
already exist. @option{-r} sets the rating for the POPM frame; you can
provide an integer between 0 and 255, or use the ``star'' system. In
this case, I've given all the files four stars. ``****'' would be more
mnemonic, but inconvenient in the shell, so @command{scribbu} will
recognize almost any character, repeated one to five times, as a
``star''.

Having created the PCNT and/or POPM frames, one can update the play
counts with a simple command; e.g.

@example
scribbu popm opium.mp3
@end example

will increment the play count by one in any @code{PCNT} or @code{POPM}
frames it finds. The operation can be scoped or modified in a number
of ways, such as limiting it to only one or the other, or only to
@code{POPM} frames with a certain owner-- see the man page or
@xref{Invoking @command{scribbu popm}}.for full details. The intent of
the command is to enable players that don't update the playcount or
set ratings themselves, but which can be scripted or extended in some
way, to do so.


@node scribbu rename
@subsection scribbu rename

Finally, let us re-name the files based on their ID3 tags:

@example
scribbu rename *.mp3
@end example

Will by default rename each file to ``<artist> - <title>.mp3'' with
@code{<artist>} & @code{<title>} each derived from the corresponding
ID3v2 frame (@xref{Invoking @command{scribbu rename}}.) This can be
customized by providing a ``template'': text interspersed with
replacement parameters to be filled in with tag contents. The
parameters begin with a `%', and each parameter has a one-character
``short'' form and a more descriptive ``long'' form. For instance,
``artist'' can be represented as either %A or %(artist). So the
default template could be expressed as ``%A - %T.mp3'' or ``%(artist)
- %(title).mp3''.

If the long form is used, the action of the replacement parameter may
optionally be modified by options given after the parameter name and a
colon in ``query-style'': @code{opt0&opt1&opt2...} where @code{opti}
is in the form @code{name=value} or just @code{name}. For instance, we
wanted the artist to always be taken from the ID3v1 tag, and that
field happens to use the ISO-8859-1 character encoding, we could
say:

@example
%(artist:v1-only&v1-encoding=iso-8859-1) 
@end example

Let us accept the default settings, but see what would happen
without actually re-naming anything:

@example
scribbu rename -n *.mp3
"lorca.mp3" => "Pogues, The - Lorca's Novena.mp3"
"opium.mp3" => "Stephan Luke - Opium Chant Intro.mp3"
"orlando.mp3" => "Bill LeFaive - Orlando.mp3"
@end example

Before we rename the files, there is a lot more hygiene that could
be carried out. ``lorca.mp3'' has a number of empty text frames
that should be removed, ``opium.mp3'' has a comment frame with no
owner, and the ID3v1 genre in all three is set to ``255''.

As I developed scribbu, and began using it to manage my personal music
collection, it became clear that providing a sub-command for every
conceivable operation was not feasible. Furthermore, many of the
things I wanted it to do were one-off tasks pertinent to a single
file, or a handful of files, that weren't worth formally coding up as
sub-commands. What I really wanted was a way to ``script''
@code{libscribbu} (@xref{Using @code{libscribbu}}.) I found my
solution in Guile (@xref{Top,,, Guile, The Guile Reference Manual}.),
which is the topic of the next chapter.


@node Invoking @command{scribbu dump}
@section Invoking @command{scribbu dump}
@cindex Invoking @command{scribbu dump}

@code{scribbu dump} will walk each file and/or directory specified
(recursing directories), read each file found, look for ID3 tags
therein, and pretty-print what it finds to @code{stdout}.

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* @code{scribbu dump} Options::
@end menu

@node @code{scribbu dump} Options
@subsection @code{scribbu dump} Options
@cindex @code{scribbu dump} Options

@code{scribbu dump} accepts the following options:

@enumerate

@item 
@option{-1|--id3v1-tags} display only ID3v1 tags

@item
@option{-D|--track-data} display track data only

@item 
@option{-2|--id3v2-tags} display only ID3v2 tags

@item
@option{-i arg|--indent=arg} indent all output @verb{.arg.} spaces

@item
@option{-g|--no-expand-genre} don't attempt to expand the genre when
specified as a numeric constant

@item
@option{-e regex|--expression=regex} define a regular expression for
filtering the files to be pretty-printed. For each file, its entire
path will be matched against this regular expression before being
pretty-printed (non-matches will be ignored).

@item
@option{-f FMT|--format=FMT} specify the desired output format; at
present, only two values are supported for this option:
@code{standard}, which is the default, pretty-prints the selectd
portions of each file to @verb{.stdout.} with one attribute (artist,
title &c) per line.  A format of @code{csv} will print one line in CSV
format per file.

The precise columns output in @code{csv} format will depend on the
other options, but for ID3v2 tags include:

version, revision, size, flags, unsynchronised, artist, title,
album, genre, encoded by, year, languages, play count, comments

for track data: size & MD5 checksum

for ID3v1 tags: v1.1, extended, artist, title, album, year, comment & genre.

@item
@option{-c ENC|--v1-encoding=ENC} specify an encoding for ID3v1 tags
(@verb{.CP1252.} by default). See @xref{Character Encodings}. for a
complete list of the encodings supported and their identifiers.

@end enumerate

@node Invoking @command{scribbu report}
@section Invoking @command{scribbu report}
@cindex Invoking @command{scribbu report}

@command{scribbu report} will walk each file and/or directory specfied
(recursing directories), read each file found, look for ID3 tags
therein, and generate a report on their contents. The idea is to use
scribbu to do the work of scanning the tags in combination with some
other tool better suited to querying & reporting. Consequently,
filtering mechanisms are minimal, and the output formats (CSV or TDF)
are chosen to facilitate transformation to other formats as well as
import by other tools.

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* @code{scribbu report} Options::
@end menu

@node @code{scribbu report} Options
@subsection @code{scribbu report} Options
@cindex @code{scribbu report} Options

@enumerate

@item
@option{-c ARG|--num-comments=ARG} number of comments to be reported;
the total number of comment frames is always reported, but this
governs the number of comment frames (owner, text &c) to be included
in the report (default six)

@item
@option{-o ARG|--output=ARG} the file to which the report shall be written

@item
@option{-1 ENC|--v1-encoding=ENC} specify the encoding @xref{Character
Encodings}. to be used to read ID3v1 tags (defaults to @verb{.CP1252.}

@item
@option{-t|--tsv-format} select tab-delimited format instead of
comma-separated values (the default).

@item
@option{-a|--ascii-delimited} @emph{if} using tab-delimited format,
output ASCII-delimited text by using 0x1f (the ASCII unit separater)
to delimit fields rather than TABs.

@end enumerate

@node Invoking @command{scribbu rename}
@section Invoking @command{scribbu rename}
@cindex Invoking @command{scribbu rename}

@code{scribbu rename} will walk each file and/or directory specified
(recursively, in the case of directories) and rename each ID3-tagged
file found according to its tag(s). By default, each ID3-tagged file
will be renamed to ``<artist> - <title>.<extension>'' (where
@code{<artist>} & @code{<title>} are derived from the file's ID3
tags), but this can be heavily customized by specifying a naming
``template'' made up of a mixture of text and replacement parameters
(such as artist, title, album &c).

Replacement parameters begin with a @verb{.%.} character (percent
characters that do @emph{not} begin a replacement parameter may be
escaped with a backslash). Each replacement parameter has a
one-character ``short'' form as well as a ``long-form'' name. For
example, the @dfn{artist} replacement can be represented as either
@verb{.%A.}  or as @verb{.%(artist).}.

When the long form is used, the action of replacement may optionally
be modified by giving options after a colon. The options take the form
@code{opt0&opt1&opt2&...} where @code{opti} is of the form
@code{name=value}, or just @code{name}. So to continue the above
example, if we wanted the artist name to instead be derived from the
ID3v1 tag, and that field was encoded as ISO-8859-1, we would say:

@example
%(artist:v1-only&v1-encoding=iso-8859-1)
@end example

See @xref{Tag-Based Replacements}. for a complete list of replacement
parameters & their options.

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* @code{scribbu rename} Options::
* Tag-Based Replacements::
* File-based Replacements::
@end menu

@node @code{scribbu rename} Options
@subsection @code{scribbu rename} Options
@cindex @code{scribbu rename} Options

@enumerate

@item
@option{-h,--help} Display help & exit

@item
@option{-n,--dry-run} Dry-run; only print what @emph{would} happen

@item
@option{-o ARG,--output=ARG,} If specified, copy the output files to
this directory, rather than renaming in-place.

@item
@option{-r,--rename} Remove the source file (ignored if
@option{--dry-run} is given)

@item
@option{-t TEMPLATE,--template=TEMPLATE} The template by which to 
rename ID3-tagged files in the arguments (defaults to ``%A - %T.mp3''

@item
@option{-v,--verbose} Produce verbose output.

@end enumerate

@node Tag-Based Replacements
@subsection Tag-Based Replacements
@cindex Tag-Based Replacements

Tag-based replacement parameters:

@multitable {content type} {short-form} {content-type,genre}
@headitem Content @tab Short-Form @tab Long-Form
@item album @tab L @tab albim
@item artist @tab A @tab artist
@item content type @tab G @tab content-type,genre
@item encoded by @tab e @tab encoded-by
@item title @tab T @tab title
@item year @tab Y @tab year
@end multitable

Tag-based replacement parameters take the following options:

@enumerate

@item 
Source of the replacement text:
@enumerate
@item
prefer-v2
@item
prefer-v1
@item
v2-only
@item
v1-only
@end enumerate

@item 
character encoding when the ID3v1 tag is used: @code{v1-encoding=}...

@enumerate
@item
auto
@item
iso-8859-1
@item
ascii
@item
cp1252
@item
utf-8
@item
utf-16-be
@item
utf-16-le
@item
utf-32
@end enumerate

@item
Handling ``The...'': @code{the=}...

@enumerate
@item
suffix (i.e. ``The Pogues'' will be changed to ``Pogues, The'')

@item
prefix

@end enumerate

@item
capitalization: @code{cap=}...

@enumerate
@item
all-upper
@item
all-lower
@end enumerate

@item
handling whitespace: either @code{compress} can be given (to merge space
between words to a single space) or @code{ws=TEXT} can be given to replace
whitespace (e.g. if @code{ws=_} were given, ``a    b'' would become ``a_b''.
@end enumerate

Lastly, the year can be formatted as two digits or four by giving
``yy'' or ``yyyy'' in the options for @code{%(year)}.

E.g. @code{%(artist:prefer-v2&v1-encoding=cp1252&the=suffix&compress)}
applied to a file whose ID3v2 tag had an artist frame of "The  Pogues"
would produce "Pogues, The".

@node File-based Replacements
@subsection File-based Replacements
@cindex File-based Replacements

There are a few more replacement parameters based on the file itself:

@enumerate

@item
@code{b,basename}: The file basename

@item
@code{E,extension}: The file extension (including the dot)

@end enumerate

Both of these take the same ``The,'', capitalization & whitespace options as
@xref{Tag-Based Replacements}.

@enumerate

@item
@code{5,md5}: the MD5 checksum of the file's audio data

@item
@code{S,size}: the file size, in bytes

@end enumerate

Both of these take the following options:

@enumerate

@item
@code{base=(decimal|hex)}: specify the radix for the numbers

@item
@code{hex-case=(U|L)}: case to use for hexidecimal numbers

@end enumerate


@node Invoking @command{scribbu popm}
@section Invoking @command{scribbu popm}
@cindex Invoking @command{scribbu popm}

@command{scribbu popm} creates or updates play count and/or
popularimeter frames. With no options, it increments the counter fields in
every and/or play count popularimeter frame in every tag by one. With the
@option{--create} flag, create the relevant frames in each tag.
Popularimeter frames will not be created in the absence of the
@option{--owner} option.  Play count & popularimeter frame creation
can be inhibited via the @option{--popularimeter-only} and
@option{--playcount-only} flags, respectively.

The popularimeter rating field can be set using the 
@option{--rating} option. Ratings can be specified explicitly
as an integer between 0 & 255, or as one-to-five stars. ``Stars''
would most naturally be expressed as @verb{.*.}s (asterisks), but
since this will often be inconvenient in the shell, @command{scribbu}
will accept almost any character, repeated one-to-five times.

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* @code{scribbu popm} Options::
@end menu

@node @code{scribbu popm} Options
@subsection @code{scribbu popm} Options
@cindex @code{scribbu popm} Options

@enumerate

@item
@option{-h,--help} display help & exit with status zero

@item
@option{-n,--dry-run} don't modify the files named in the arguments; just
print what @emph{would} have been done

@item
@option{-a,--create} create playcount and/or popularimeter in any tags
that are missing. This can be modified by the
@option{--popularimeter-only} and @option{--playcount-only} flags,
respectively. Popularimeter frames will only be created if the
@option{--owner} flag is given, as well.

@item
@option{-b,--create-backups} by default, the new tagset will be written
in-place (emplacing, if possible); this option will cause a backup file
to be made first.

@item
@option{-c COUNT,--count=COUNT} set all counter fields to @verb{.COUNT.}
instead of incrementing

@item
@option{-i INCR,--increment=INCR} increment all counter fields by
@verb{.INCR.}, instead of by one.

@item
@option{-o OWNER,--owner=OWNER} Specify the owner field for popularimeter
frames. If incrementing count fields, only popularimeter frames with an 
owner of @verb{.OWNER.} will be updated. When creating popularimeter frames,
the owner field will be set to @verb{.OWNER.}.

@item
@option{-p,--playcount-only} if present, this switch will limit operations
to playcount frames only

@item
@option{-m,--popularimeter-only} if present, this switch will limit operaitons
to popularimeter frames only

@item
@option{-r RATING,--rating=RATING} specify the rating for use in
popularimeter tags. @verb{.RATING.} may be given either as an integer
between 0 & 255 (inclusive) or as one-to-five ``stars'', given as
@code{[a-zA-Z@@#%*+]@{1,5@}} e.g.  three stars could be expressed as
``xxx'' or ``###'' or ``***''.

@item
@option{-t INDEX,--tag=INDEX} specify a zero-based index describing
which tag to alter, in case of multiple ID3v2 tags in a single
file. This option may be given more than once to indicate multiple
tags. If not given, @emph{all} tags will be modified.

@item
@option{-u,--adjust-unsync} adjust each tag's use of the
unysnchronisation scheme on write (by default, it's never used)

@end enumerate


@node Invoking @command{scribbu text}
@section Invoking @command{scribbu text}
@cindex Invoking @command{scribbu text}

@code{scribbu text} will create, udpate & delete various ID3v2 text
frames.

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* @code{scribbu text} Options::
@end menu

@node @code{scribbu text} Options
@subsection @code{scribbu text} Options
@cindex @code{scribbu text} Options

@enumerate

@item
@option{-a ALBUM,--album=ALBUM} set the TALB, or Album/Movie/Show
Title frame

@item
@option{-A ARTIST,--artist=ARTIST} Set the TPE1, or Lead
artist(s)/Lead performer(s)/Soloist(s)/Performing group frame

@item
@option{-e ENC,--encoded-by=ENC} Set the TENC, or Encoded By frame

@item
@option{-g GENRE,--genre=GENRE} Set the TCON, or Content time frame

@item
@option{-T TITLE,--title=TITLE} Set the TIT2, or
Title/Songname/Content description frame

@item
@option{-k TRACK,--track=TRACK} Set the TRCK, or Track number/Position
in set frame

@item
@option{-y YEAR,--year=YEAR} Set the TYER, or Year frame

@item
@option{-d FRAME,--delete=FRAME} Specify a frame to remove, if
present; this option may be given more than once to delete multiple
frames. Frames may be named by either their option name
(e.g. `artist') or by their ID3v2.3 frame ID (e.g. TPE1).

@item
@option{-E ENC,--encoding=ENC} Specify the character encoding used in
the input strings using the iconv name (`ISO-8859-1', e.g.) If not
given, the system locale will be assumed (@xref{Character Encodings}.
for a complete list of the encodings supported and their identifiers).

@item
@option{-t INDEX,--tag=INDEX} Zero-based index of the tag on which to
operate; may be given more than once to select multiple tags

@item
@option{-u,--adjust-unsync} Update the unsynchronisation flag as
needed on write (default is to never use it).

@item
@option{-b,--create-backups} Create backup copies of all files before
modifying them.

@end enumerate


@node Scripting @command{scribbu}
@chapter Scripting @command{scribbu}
@cindex Scripting @command{scribbu}

The set of sub-commands @command{sribbu} offers, or could offer, is
small in comparison to the number of operations one could possibly
hope to carry out in managing ID3 tags. Sooner or later (likely sooner)
you will want to do something you can't accomplish via a sub-command.

For that reason, the bulk of the work on @command{scribbu} has been
exposing the library's functionality to a first-class language like
LISP (@xref{Top,,, Guile, The Guile Reference Manual}.), to enable
@command{scribbu} users to build their own solutions. 

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* Worked Example::
* ID3v1 tags::
* ID3v2 tags::
* Text Encoding::
@end menu

@node Worked Example
@section Worked Example

This chapter begins by demonstrating how to use the interactive Scheme
REPL to explore solutions, then demonstrates building Scheme programs
using @command{scribbu}, and finishes with some references.

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* Initial Experiments: The Scheme REPL.
* Writing Scheme Programs with @command{scribbu}::
* Getting More Information::
@end menu

@node The Scheme REPL
@subsection The Scheme REPL
@cindex The Scheme REPL

At the end of ``scribbu rename'' (@xref{scribbu rename},) there were a
number of tag hygiene issues to be cleaned up. Let us begin
experimenting with solutions. Invoking @command{scribbu} with no
arguments at all will start the Scheme REPL:

@example
$>: scribbu
scribbu 0.5
Copyright (C) 2017-2019 Michael Herstine <sp1ff@@pobox.com>

You are in the Guile REPL; in your shell, type `info scribbu' for documentation.

GNU Guile 2.2.2
Copyright (C) 1995-2017 Free Software Foundation, Inc.

Guile comes with ABSOLUTELY NO WARRANTY; for details type `,show w'.
This program is free software, and you are welcome to redistribute it
under certain conditions; type `,show c' for details.

Enter `,help' for help.
scheme@@(guile-user)>
@end example

You are now at the Scheme prompt (``scheme'' refers to the language
currently in use and ``guile-user'' refers to the current module). You can
type Scheme statements & have your statements evaluated:

@lisp
scheme@@(guile-user)> (format #t "Hello, world!")
Hello, world!$1 = #t
scheme@@(guile-user)> (define x 1)
scheme@@(guile-user)> (set! x (+ x 1))
scheme@@(guile-user)> x
$2 = 2
scheme@@(guile-user)> (if (> x 1) (format #t "Yes!"))
Yes!$3 = #
scheme@@(guile-user)>
@end lisp

@code{scribbu} exports assorted types & functions for working with ID3
tags to the Guile interpreter. Let's take a look at that owner-less
comment frame. We begin by reading in the ID3v2 tagset:

@lisp
scheme@@(guile-user)> (use-modules (oop goops) (scribbu))
scheme@@(guile-user)> (define tags (read-tagset "opium.mp3")) 
scheme@@(guile-user)> tags
$4 = ((#<<id3v2-tag> 1ccf780> 3 #f))
@end lisp

@code{read-tagset} returns a list of three-tuples, one for each ID3v2
tag present in its argument. Since ``opium.mp3'' has only one ID3v2
tag, the list has only one element. The triplet consists of an
@code{<id3v2-tag>} instance, the ID3v2 version (``3'' in this case)
and a boolean indicating whether the unsynchronisation flag is set (it
is not). Let's examine the tag:

@lisp
scheme@@(guile-user)> (define tag (caar tags))
scheme@@(guile-user)> tag
$5 = #<<id3v2-tag> 1ccf780>
scheme@@(guile-user)> (let ((frames (slot-ref tag 'frames)) (i 0)) (while (> (length frames) 0) (format #t "~d: ~a\n" i (slot-ref (car frames) 'id)) (set! i (+ i 1)) (set! frames (cdr frames))))
0: encoded-by-frame
1: track-frame
2: comment-frame
3: publisher-frame
4: part-of-a-set-frame
5: year-frame
6: genre-frame
7: album-frame
8: band-frame
9: artist-frame
10: unknown-frame
11: title-frame
12: play-count-frame
13: pop-frame
$6 = #f
@end lisp

We see that @code{tag} is an instance of the GOOPS class
@code{<id3v2-tag>}, and that it has 14 frames. Frame two (counting
from zero) is that comment frame:

@lisp
scheme@@(guile-user)> (slot-ref (list-ref (slot-ref tag 'frames) 2) 'dsc)
$7 = ""
@end lisp

As expected, the description field is an empty string-- let's fix that:

@lisp
scheme@@(guile-user)> (slot-set! (list-ref (slot-ref tag 'frames) 2) 'dsc "sp1ff@@pobox.com")
$8 = "sp1ff@@pobox.com"
# check
scheme@@(guile-user)> (slot-ref (list-ref (slot-ref tag 'frames) 2) 'dsc)
$9 = "sp1ff@@pobox.com"
@end lisp

Now what about that ID3v1 genre?

@lisp
scheme@@(guile-user)> (define v1 (read-id3v1-tag "opium.mp3"))
scheme@@(guile-user)> v1
$10 = #<<id3v1-tag> 18fb8c0>
scheme@@(guile-user)> (slot-ref v1 'genre)
$11 = 255
@end lisp

Let's set that to ``Lounge''-- the Winamp genre list sets that to 171:

@lisp
scheme@@(guile-user)> (slot-set! v1 'genre 171)
$12 = 171
@end lisp

What remains is writing out our modifications to their respective
tags. We @emph{could} do this directly in the REPL, but let's capture
our work in the form of a program (@xref{Writing Scheme Programs with
@command{scribbu}}.)


@node Writing Scheme Programs with @command{scribbu}
@subsection Writing Scheme Programs with @command{scribbu}

@command{scribbu} understands both its own command-line parameters as
well as those understood by the @command{guile} command. When it sees
parameters applicable to @command{guile}, it will collect them and
pass them on to the Scheme interpreter (when this makes sense, of
course; supplying @command{guile} options while invoking a
@command{scribbu} sub-command, for instance, would make no sense &
results in an error). This means that @command{scribbu} can take
advantage of the @command{guile} scripting options (@xref{Guile
Scripting,,, Guile, The Guile Reference Manual}.)

Continuing our example, let us capture our work so far:

@lisp
#!/usr/local/bin/scribbu -e main -s
#!
(use-modules (oop goops) (scribbu))

(define (main)
    (let* ((tags (read-tagset "opium.mp3"))
           (v1   (read-id3v1-tag "opium.mp3"))
           (tag  (caar tags)))
        (slot-set! (list-ref (slot-ref tag 'frames) 2) 'dsc "sp1ff@@pobox.com")
        (slot-set! v1 'genre 171)))
@end lisp

This Scheme program of course does nothing; it corrects the orphaned
comment frame as well as the ID3v1 genre, but only in-memory. Let us
write these out to disk. Writing out the ID3v1 is simpler since it's
a fixed size, so we'll start with that:

@lisp
#!/usr/local/bin/scribbu -e main -s
#!
(use-modules (oop goops) (scribbu))

(define (main)
    (let* ((tags (read-tagset "opium.mp3"))
           (v1   (read-id3v1-tag "opium.mp3"))
           (tag  (caar tags)))
        (slot-set! (list-ref (slot-ref tag 'frames) 2) 'dsc "sp1ff@@pobox.com")
        (slot-set! v1 'genre 171)
        (write-id3v1-tag v1 "optimum.mp3")))
@end lisp

Writing an ID3v1 tag is also easier because it is appended to the
file.  NB. @code{v1} may be written as an ID3v1, ID3v1.1 and/or an
ID3v1 enhanced tag, depending on the precise contents of @code{v1}
@xref{ID3v1 tags}.

Writing ID3v2 tagsets is more complicated, since their size can
vary. @code{write-tagset} can either make a wholesale copy of the
file, or attempt to emplace the new tagset at the beginning of the
extant file (which is the default):

@lisp
#!/usr/local/bin/scribbu -e main -s
#!
(use-modules (oop goops) (scribbu))

(define (main)
    (let* ((tags (read-tagset "opium.mp3"))
           (v1   (read-id3v1-tag "opium.mp3"))
           (tag  (caar tags)))
        (slot-set! (list-ref (slot-ref tag 'frames) 2) 'dsc "sp1ff@@pobox.com")
        (slot-set! v1 'genre 171)
        (write-id3v1-tag v1 "optimum.mp3")
        (write-tagset (list (list tag 3)) "opium.mp3")))
@end lisp


@node Getting More Information
@subsection Getting More Information

References:

@enumerate

@item 
@xref{Introduction,,, Guile, The Guile Reference Manual}.

@item
Scheme versus Common Lisp @uref{https://www.cs.utexas.edu/~novak/schemevscl.html}

@item

Schemers.org @uref{https://schemers.org}

@end enumerate


@node ID3v1 tags
@section ID3v1 tags

The orginal ID3v1 tag contained title, artist, album, year, comment &
genre.  The fields are fixed-size (30, 30, 30, 4, 30 & 1 byte,
respectively). The original proposal called for filling out the fields
with nil (zero) values, but that is not universally implemented
(Winamp @xref{Winamp}, for instance, pads fields out with ASCII spaces
(i.e. 32 = 0x20)).

Michael Mutschier observed that if the fields were zero-padded, an
implementation will likely stop on reading the first nil. Therefore,
if the second-to-last byte of a field is nil, a one-byte value could
be stored in the last field. He proposed storing the track number in
the last byte of the comment field. This became known as ID3v1.1.

A thirty-byte limit quickly became constraining, leading to the ID3v1
``enhanced'' specification. The origins of the proposal are unclear to
me, but the proposal itself involves @emph{prepending} a second
two-hundred twenty-seven byte block to the ID3v1 block. This would
extend the title, artist & album fields by sixty bytes each, adds a
thirty-byte free-form genre field, and introduces start-time,
end-time, and ``speed'' fields.

@code{scribbu} represents the ID3v1 tag by the GOOPS @xref{Top,,,
Guile, GOOPS}. class @code{<id3v1-tag>}:

@lisp
(define-class <id3v1-tag> ()
  (title      #:init-value ""  #:accessor title       #:init-keyword #:title)
  (artist     #:init-value ""  #:accessor artist      #:init-keyword #:artist)
  (album      #:init-value ""  #:accessor album       #:init-keyword #:album)
  (year       #:init-value '() #:accessor year        #:init-keyword #:year)
  (comment    #:init-value ""  #:accessor comment     #:init-keyword #:comment)
  (genre      #:init-value 255 #:accessor genre       #:init-keyword #:genre)
  (track-no   #:init-value '() #:accessor track-no    #:init-keyword #:track-no)
  (enh-genre  #:init-value '()  #:accessor enh-genre  #:init-keyword #:enh-genre)
  (speed      #:init-value '() #:accessor speed       #:init-keyword #:speed)
  (start-time #:init-value '()  #:accessor start-time #:init-keyword #:start-time)
  (end-time   #:init-value '()  #:accessor end-time   #:init-keyword #:end-time))
@end lisp

The class' fields include the union of all ID3v1, ID3v1.1 and ID3v1
enhanced fields. All fields above & beyond those present in ID3v1
however, have a default alue of @code{'()} (or nil, in
Scheme). Whether a given @code{<id3v1-tag>} instance is ID3v1,
ID3v1.1, and/or ID3v1 enchanced is implicitly determined by whether
any of these fields are non-nil.

One can create an @code{<id3v1-tag>} instance directly, like
any GOOPS class:

@lisp
(use-modules (oop goops))
(define tag (make <id31-tag> #:title  "The Body of an American"
                             #:artist "Pogues, The"
                             #:album  "Poguetry in Motion"
                             #:year   "1986"
                             #:genre  88))
@end lisp

One can also create an instance from an existing tag on disk:

@lisp
(use-modules (scribbu))
(define tag (read-id3v1-tag "foo.mp3"))
(format #t "~s - ~s\n" (slot-ref tag #:artist) (slot-ref tag #:title))
@end lisp

@code{<id3v1-tag}> instances can be written to disk via
@code{write-id3v1-tag}: @code{(write-id3v1-tag tag "bar.mp3")}.  The
format in which an @code{<id3v1-tag}) will be written depends upon the
optional fields. If @code{#:track-no} is non-nil (i.e. not equal to
@code{'()}) it will be written as an ID3v1.1 tag. If any of the title,
artist or album slotes are longer than thirty characters, or any of
the new fields (enhanced genreo, speed, start-time or end-time) are
non-nil, it will be written as an ID3v1 enhanced tag.


@node ID3v2 tags
@section ID3v2 tags
@cindex ID3v2 tags

The various flavors of ID3v1 tags @xref{ID3v1 tags}. had obvious
limitations, leading to the introduction in 1998 of ID3v2 (by Mrtin
Nilsson, Michael Mutschler et al.).  Despite the name, this format has
nothing to do with ID3v1.  ID3v2 tags are much more complex. The tags
are pre-pended to the files they describe. They are comprised of one
or more @dfn{frames}, each of which contains one piece of
information. There is provision for padding appended to the tag, to
permit subsequent augmentation of the tag without having to re-write
the entire file. ID3v1 tags suffered from the fact that they encoded
text as ASCII (ISO-8859-1, at most): ID3v2 carried the encoding scheme
along with textual information.

Furthermore, there are three versions of the ID3v2 spec that saw
general use:

@itemize

@item
ID3v2.2 was the first public version; it used three-character frame
identifiers instead of four; it is generally considered obsolete.

@item
ID3v2.3 introduced four-character frame identifiers as well as adding
a number of new frames along with a second, extended header. This is
the version most frequently encountered in the wild.

@item
ID3v2.4 was the last version published, but never saw widespread adoption.

@end itemize

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* The Unsynchronisation Scheme::
* ID3v2 Frames::
* @code{<id3v2-tag>}::
@end menu

@node The Unsynchronisation Scheme
@subsection The Unsynchronisation Scheme
@cindex The Unsynchronisation Scheme

MPEG decoding software uses a two-byte sentinel value in the input
stream to detect the beginning of the audio. MPEG decoding software
that is not ID3-aware could mistakenly interpret that value as the
beginning of the audio should it happen to occur in an ID3v2
tag. Unsynchronisation is an optional encoding scheme for the ID3v2
tag to prevent that. "Unsynchronisation may only be made with MPEG 2
layer I, II and III and MPEG 2.5 files."
@uref{http://id3.org/id3v2-00}

More specifically, whenever a two byte combination of the form:

@example
11111111 111xxxxx
@end example

(i.e. @code{0xFF 0xEx} or @code{0xFF 0xFx}) is encountered in an ID3v2
tag to be written to disk, it is replaced with:

@example
11111111 00000000 111xxxxx
@end example

and the @code{unsynchronisation} flag will be set.

This leaves us with an ambiguous situation on read: if we encounter
a bit pattern

@example
11111111 00000000 111xxxxx
@end example

when reading a tag with the unsynchronisation flag set, we have no way to
know whether that was a false sync that was unsynchronised (and so the three
bytes should be interpreted as @code{11111111 111xxxxx} or whether those three
bytes had occurred naturally in the tag when it was written. To resolve
this, on applying unsynchronisation all two-byte sequences of the form 
@code{$FF 00} should also be written as @code{$FF 00 00}.

ID3v2.4 introduced unsynchronisation at a frame level; the
unsynchronisation flag in the header being set indicates that all
frames are unsynchronised; unset in the header means that at least one
frame is *not* unsynchronised.

Note that since the point of unsynchronisation is to avoid presenting
a false sync point to the MPEG decoding software, unsynchronisation
should be employed @emph{last}, after any compression or encryption.


@node ID3v2 Frames
@subsection ID3v2 Frames
@cindex ID3v2 Frames

All ID3v2 frames subclass GOOPS class @code{<id3v2-frame>}:

@lisp
(define-class <id3v2-frame> ()
  (id     #:init-value 'unknown-frame #:accessor id     #:init-keyword #:id)
  (tap    #:init-value '()            #:accessor tap    #:init-keyword #:tap)
  (fap    #:init-value '()            #:accessor fap    #:init-keyword #:fap)
  (ro     #:init-value '()            #:accessor ro     #:init-keyword #:ro)
  (unsync #:init-value '()            #:accessor unsync #:init-keyword #:unsync))
@end lisp

@code{id} is a symbol naming the frame @xref{Frame Identifiers}. The remaining
four fields are frame flags that can be either true (@code{#t}), false
(@code{#f}) or just left undefined (@code{'()}):

@enumerate

@item
@code{tap} Tag Alter Preserve ``This flag tells the software what to
do with this frame if it is unknown and the tag is altered in any
way. This applies to all kinds of alterations, including adding more
padding and reordering the frames.''  Sec 3.3.1

@item
@code{fap} File Alter Preserve ``This flag tells the software what to
do with this frame if it is unknown and the file, excluding the tag,
is altered. This does not apply when the audio is completely replaced
with other audio data.'' Sec 3.3.1

@item
@code{ro} Read Only ``This flag, if set, tells the software that the
contents of this frame is intended to be read only. Changing the
contents might break something, e.g. a signature. If the contents are
changed, without knowledge in why the frame was flagged read only and
without taking the proper means to compensate, e.g. recalculating the
signature, the bit should be cleared.'' Sec 3.3.1

@item
@code{unsync} Unsynchronisation 
In ID3v2.2 & ID3v2.3, a value of @code{#t} for this flag indicates that
the unsynchronisation scheme @xref{The Unsynchronisation Scheme}, has been
applied to this tag. In ID3v2.4, it indicates that it has been applied to
all frames.

@end enumerate

Module @code{scribbu} defines a few @code{<id3v2-frame>} sub-classes.


@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* @code{<text-frame>}::
* @code{<comment-frame>}::
* @code{<user-defined-text-frame>}::
* @code{<play-count-frame>}::
* @code{<popm-frame>}::
* @code{<unk-frame>}::
@end menu

@node @code{<text-frame>}
@subsubsection @code{<text-frame>}
@cindex @code{<text-frame>}

A great many ID3v2 frames represent textual information (title, artist
&c) and are represented in a uniform way, distinguished only by frame
identifer.  @code{scribbu} represents such frames as instances of
@code{<id3v2-frame>}:

@lisp
(define-class <text-frame> (<id3v2-frame>)
  (text #:init-value "" #:accessor text #:init-keyword #:text))
@end lisp

@node @code{<comment-frame>}
@subsubsection @code{<comment-frame>}
@cindex @code{<comment-frame>}

@code{<comment-frame>} encodes the @verb{.COM.} & @verb{.COMM.}
(comment) frames. @code{#:lang} is a three-letter ISO-639-2 language
code.  The @code{#:dsc} fields is described in the specification as a
``short content description''.

@lisp
(define-class <comment-frame> (<id3v2-frame>)
  (lang  #:init-value "eng" #:accessor lang #:init-keyword #:lang)
  (dsc   #:init-value ""    #:accessor dsc  #:init-keyword #:dsc)
  (text  #:init-value ""    #:accessor text #:init-keyword #:text))
@end lisp

@node @code{<user-defined-text-frame>}
@subsubsection @code{<user-defined-text-frame>}
@cindex @code{<user-defined-text-frame>}

@code{<user-defined-text-frame>} encodes the @verb{.TXX.} &
@verb{.TXXX.}  (user-defined text) frames. The @code{#:dsc} fields is
a description of the textual information & @code{#:text} is the
information itself. There may be multiple user-defined text frames in
a tag, but only one with a given description. Cf. section 4.2.2 of the
ID3v2 spec.

@lisp
(define-class <user-defined-text-frame> (<id3v2-frame>)
  (dsc   #:init-value "" #:accessor dsc  #:init-keyword #:dsc)
  (text  #:init-value "" #:accessor text #:init-keyword #:text))
@end lisp

@node @code{<play-count-frame>}
@subsubsection @code{<play-count-frame>}
@cindex @code{<play-count-frame>}

@code{<play-count-frame} encodes the @verb{.CNT.} & @verb{.PCNT.} (play
count) frames. The @code{#:count} field is simply a counter recording
the number of times the file has been played @xref{scribbu
popm}. There may be only one @code{<play-count-frame} frame in a
tag. Cf. section 4.17 of the ID3v2 spec.

@lisp
(define-class <play-count-frame> (<id3v2-frame>)
  (count #:init-value 0 #:accessor count #:init-keyword #:count))
@end lisp

@node @code{<popm-frame>}
@subsubsection @code{<popm-frame>}
@cindex @code{<popm-frame>}

@code{<pop-frame>} encodes the @verb{.POP.} & @verb{.POPM.} (popularimeter)
frames. @code{<pop-frame>} combines an eight-bit rating field with a
@code{<play-count-frame>}-style play count. Unlike @code{<play-count-frame>},
there may be multiple @code{<pop-frame>} frames because each is
tagged with the e-mail address of the author.

@lisp
(define-class <pop-frame> (<id3v2-frame>)
  (e-mail #:init-value "" #:accessor e-mail #:init-keyword #:e-mail)
  (rating #:init-value 0  #:accessor rating #:init-keyword #:rating)
  (count  #:init-value 0  #:accessor count  #:init-keyword #:count))
@end lisp

@node @code{<unk-frame>}
@subsubsection @code{<unk-frame>}
@cindex @code{<unk-frame>}

Frames about which @code{scribbu} does not know may be encoded as
@code{<unk-frame>} instances:

@lisp
(define-class <unk-frame> (<id3v2-frame>)
  (id-text #:init-value ""     #:accessor frameid #:init-keyword #:frameid)
  (data    #:init-value #vu8() #:accessor data    #:init-keyword #:data))
@end lisp

The @code{data} field will contain everything @emph{beyond} the ID3v2 header;
i.e. the frame identifier & flags will have been parsed out.

@node @code{<id3v2-tag>}
@subsection @code{<id3v2-tag>}
@cindex @code{<id3v2-tag>}

The @command{scribbu} ID3v2 tag abstraction doesn't try to model the various
versions of the ID3v2 spec. Rather, it encodes a ``generic'' ID3v2 tag; the
version to which it shall be serialized is specified at write time, and
the version from which it was deserialized is returned at read time
(@xref{ID3v2 Serialization}.)

@lisp
(define-class <id3v2-tag> ()
  (experimental #:init-value '() #:accessor experimental
                #:init-keyword experimental)
  (frames       #:init-value '() #:accessor frames  #:init-keyword #:frames)
  (padding      #:init-value   0 #:accessor padding #:init-keyword #:padding))
@end lisp

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* ID3v2 Serialization::
* @code{with-track-in}::
@end menu

@node ID3v2 Serialization
@subsubsection ID3v2 Serialization
@cindex ID3v2 Serialization

While you can of course create an @code{<id3v2-tag>} instance ``from
scratch'' (in-memory, as a result of a call to @code{(make <id3v2-tag>
...)} you will more frequently be reading them from files on
disk.

The function for doing this is @code{read-tagset}. The name is intended
as a reminder that a file can have multiple ID3v2 tags, so you are in
general reading a tag @emph{set}, not just a tag.

@lisp
scheme@@(guile-user)> (define tags (read-tagset "opium.mp3"))
scheme@@(guile-user)> tags
$1 = ((#<<id3v2-tag> 56188c2a3d80> 3 #f))
@end lisp

@code{read-tagset} returns a list of three-tuples, one tuple for
each tag (so it could return @code{'()}, if the file contained no
ID3v2 tags). Each three tuple contains:

@enumerate

@item
an @code{<id3v2-tag>} instance, representing the tag

@item
the ID3v2 version as which the tag was serialized (i.e. 2, 3 or 4)

@item
a boolean indicating whether the unsynchronisation bit was set
@xref{The Unsynchronisation Scheme}.

@end enumerate

Once you've created or updated your ID3v2 tag(s), you will presumably
want to write it (them) to disk, presumably in place of an existing
tagset. This is done via @code{write-tagset(tags, file,
...)}. @code{tags} is a list of two-tuples: the first element is
always an @code{<id3v2-tag>} isntance to be written to disk & the
second is the ID3v2 version under which it shall be serialized
(i.e. an int, either 2, 3 or 4). @code{file} is the file into which
the new tagset shall be written, replacing any tagset present therein.

@code{write-tagset} takes a few optional parameters:

@enumerate

@item
@code{#:apply-unsync} governs whether the unsynchronisation scheme
@xref{The Unsynchronisation Scheme}, should be applied when writing out
the given tags: @code{#f} (the default) means never, @code{#t} means
it will always be applied and @code{'as-needed} means that it will be
applied to any tag whose serialization would contain false syncs.

@item
@code{#:copy} governs whether a backup copy of the target file will be
made: a value of @code{#f} (the default) means that the new tagset
will be written in place (moving the audio data & ID3v1 tag, if any,
if needed) and a value of @code{#t} means that the target file will be
copied to a backup, the new tagset will be written, and then the track
data & ID3v1 tag (if any) will be copied over to the new file.

@end enumerate

@node @code{with-track-in}
@subsubsection @code{with-track-in}
@cindex @code{with-track-in}

@code{with-track-in(directory, fn)} is a convenience function; it will
iterate over all filesystem entities in @code{directory} and apply
@code{fn} to them. @code{fn} shall be a function taking three parameters:

@enumerate

@item
a tagset, such as what is returned from @code{read-tagset}

@item
a string naming the fileystem entity

@item
an ID3v1 tag (nil if none exists)

@end enumerate

@lisp
scheme@@(guile-user)> (with-track-in "." (lambda (tags pth v1) (format #t "~s has ~d ID3v2 tags\n" pth (length tags))))
"./track.dat" has 0 ID3v2 tags
"./id3v22-tda.mp3" has 1 ID3v2 tags
...
@end lisp


@node Text Encoding
@section Text Encoding
@cindex Text Encoding

The various string fields bring up the question: what text encoding is
used? There are actually three text encodings in play:

@enumerate

@item
the encoding in use in your Scheme source files

@item
the encoding in use within the Guile interpreter

@item
the encoding in use in @code{libscribbu}

@end enumerate

The first is documented in the Guile manual under ``Character Encoding
of Source Files'' @xref{Character Encoding of Soruce Files,,, Guile,
The Guile Reference Manual}. The upshot is this: UTF-8 is assumed, but
the author may tell Guile what is being used through a coding hint:

@lisp
;;; coding: iso-8859-1
@end lisp

The set of encodings recognized is defined by IANA in RFC2978.

The second is also documented in the Guile manual, under ``String
Internals'' @xref{String Internals,,, Guile, The Guile Reference
Manual}.:

@quotation
Guile stores each string in memory as a contiguous array of Unicode
code points along with an associated set of attributes. If all of the
code points of a string have an integer range between 0 and 255
inclusive, the code point array is stored as one byte per code point:
it is stored as an ISO-8859-1 (aka Latin-1) string. If any of the code
points of the string has an integer value greater that 255, the code
point array is stored as four bytes per code point: it is stored as a
UTF-32 string.

Conversion between the one-byte-per-code-point and
four-bytes-per-code-point representations happens automatically as
necessary.
@end quotation

That just leaves @code{libscribbu}. On read (that is, when the library
reads text from tags on disk), the encoding is sometimes specified by
the tag itself, or is specified by the caller, or is guessed. From
there, it will be converted to a Guile string. On write, text will
be converted from the internal Guile representation to the desired
text encoding on disk (deduced from either caller preferences or the
frame settings themselves).


@node Using @code{libscribbu}
@chapter Using @code{libscribbu}
@cindex Using @code{libscribbu}

The third way in which to use scribbu is to link against the library
@code{libscribbu}. Detailed documentation can be found in the 
@code{libscribbu} source itself (Doxygen documentation can be
produced by doing @code{cd doc && make doxygen-doc}).

While detailed documentation on individual classes, free functions,
and sub-systems may one day make it's way into this manual, for now
this chapter will describe using the library through a worked
example. This example can be found in the @file{examples/az-tags}
sub-directory of the scribbu source distribution.

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* Building a @code{libscribbu} program::
@end menu

@node Building a @code{libscribbu} program
@section Building a @code{libscribbu} program
@cindex Building a @code{libscribbu} program

Let us write a small C++ program using @code{libscribbu} to clean-up
Amazon.com Song IDs. When downloading @file{.mp3s} from Amazon.com,
their ID3v2 tags contain non-compliant comment frames (in that they
have no description). They also try to cram it into the comment field
in the ID3v1 tag, even though it's generally too small to contain the
entire string. We will call this program @code{az-tags}.

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* Implementing @code{az-tags}::
* Building @code{az-tags}::
@end menu

@node Implementing @code{az-tags}
@subsection Implementing @code{az-tags}
@cindex Implementing @code{az-tags}

The complete source for the program can be found in
@file{examples/az-tags/main.cc} in the source distribution. The logic 
is simple enough to fit completely in @code{main}. The usage is:

@example
az-tags [-h] [-v] file [file...]
@end example

Skipping command line parsing, we begin by initializing the library:

@example
// ...
#include <scribbu/scribbu.hh>
// ...
int
main(int argc, char * argv[]) 
@{
    // Parse command-line options...
    scribbu::static_initialize()
@end example

@code{libscribbu} needs to carry out assorted initialization; rather
than deal with the static initialization problem, it just depends on the
caller to explicitly initialize the library.

At this point, the first filename is waiting in @code{argv[optind]}, so
we can set the basic structure of the program:

@example
    for (int i = optind; i < argc; ++i) @{
        // ...
    @}
@end example

For each file, we will open it & parse it into its ID3v2 tags, track
data and ID3v1 tag:

@example
  for (int i = optind; i < argc; ++i) @{

    fs::ifstream ifs(argv[i], ios_base::binary); // 1

    vector<unique_ptr<scribbu::id3v2_tag>> id3v2;
    scribbu::read_all_id3v2(ifs, back_inserter(id3v2)); // 2
    scribbu::track_data td((istream&)ifs); // 3
    unique_ptr<scribbu::id3v1_tag> pid3v1 = scribbu::process_id3v1(ifs); // 4
@end example

At @code{1}, we open the file, taking care to use binary mode so as to avoid
newline translation. At @code{2} we ask @code{libscribbu} to read any and
all ID3v2 tags into @code{id3v2}. We've used a @code{vector} here, but we
can use any container providing a forward output iterator.

At this point, the file pointer is pointing just past the last ID3v2
tag (if an-- there may be none, in which case the file pointer remains
at the beginning of the file and @code{id3v2} is empty). The easiest
way to consume the track data is to construct a @code{track_data}
isntace with it. This will collect some data about the track and
advance the file pointer to the one-past-the-end point.

There may or may not be some kind of ID3v1 tag waiting for us. That 
is why @code{process_id3v1} returns a @code{unique_ptr}-- if there
is no ID3v1 tag, a null pointer will be returned.

We now have zero or more ID3v2 tags to be processed in @code{id3v2}:

@example
    for (auto &ptag: id3v2) @{
        // `ptag' is a reference to a unique_ptr<id3v2_tag>
        // how to get at its frames?
    @}
@end example

It is at this point that the @code{libscribbu} API turns out to be
less than ergonmic. The issue is that @code{read_all_id3v2} returns
the tags typed as pointers to @code{id3v2_tag}; this is a base class
providing a ``generic'' interface supported by all ID3v2 tags, but the
API for iterating over frames is provided individually by each
sub-class (@code{id3v2_2_tag}, @code{id3v2_3_tag} &
@code{id3v2_4_tag}).

Perhaps it would be worth it to provide an interface on the base class
to do this, but for now, I simply @code{dynamic_cast} & dispatch to a
template function @code{process_tag}:

@example
    for (auto &ptag: id3v2) @{
      switch (ptag->version()) @{
      case 2: @{ // ID3v2.2 tag
        scribbu::id3v2_2_tag &p = dynamic_cast<scribbu::id3v2_2_tag&>(*ptag);
        process_tag(p);
        break;
      @}
      case 3: @{ // ID3v2.3 tag
        scribbu::id3v2_3_tag &p = dynamic_cast<scribbu::id3v2_3_tag&>(*ptag);
        process_tag(p);
        break;
      @}
      case 4: @{ // ID3v2.4 tag
        scribbu::id3v2_4_tag &p = dynamic_cast<scribbu::id3v2_4_tag&>(*ptag);
        process_tag(p);
        break;
      @}
    default:
      cerr << "Unknown ID3v2 revision " << ptag->version() << endl;
      abort();
      @}
    @}
@end example

The template parameter is the @code{id3v2_tag} sub-class. Since there
are only three, I can factor out the ID3v2-version-specific logic
into a traits class:

@example
template <class tag_type>
void
process_tag(tag_type &T)
@{
 ...
  
  for (auto fp: T) @{ // 1
    if (traits_type::COMMID == fp->id()) @{ // 2

      id3v2_frame &F = fp;
      comm_type &C = dynamic_cast<comm_type&>(F); // 3

      string dsc = C.template description<string>();
      if (dsc.empty()) @{
        string txt = C.template text<string>();
        if ("Amazon.com Song ID" == txt.substr(0, 18)) @{
          cout << "updating the comment frame containing " << txt << endl;
          fp = traits_type::replace(C);
        @}
      @}
    @}
  @}
@}
@end example

Each concreate @code{id3v2_tag} subclass implements @code{begin} &
@code{end}, so we can use instances thereof as targets in for range
loops like 1. @code{fp} is actually a mutable proxy for an
ID3v2-version-specific @code{id3v2_frame} subclass. At 2 we have
factored out the precise frame ID to select for comments frames.

Each ID3v2 version has a concrete comment frame type, to which 
we again dynamically cast (I really need to re-evaluate this interface)
at 3.

The rest of the logic is straightforward-- if there is no description
field in the comments frame, and the comment text begins with
``Amazon.com Song ID'', replace the frame.

@node Building @code{az-tags}
@subsection building @code{az-tags}
@cindex Building @code{az-tags}

The next step is to compile the program. We shall use Autotools, beginning
with the simplest @code{configure.ac} we can:

@example
AC_PREREQ([2.69])
AC_INIT([az-tags], [0.1], [sp1ff@@pobox.com])
AC_CONFIG_MACRO_DIR([macros])
AC_CONFIG_SRCDIR([src/main.cc])
AC_CONFIG_AUX_DIR([build-aux])
AC_CONFIG_HEADERS([config.h])
AM_INIT_AUTOMAKE([-Wall -Werror])
LT_INIT
AC_RROG_CXX
AC_CONFIG_FILES([Makefile src/Makefile])
@end example

@code{AC_PREREQ} just asserts that Autoconf 2.69 is required to build
a @code{configure} script from this template. @code{AC_INIT} is the
Autoconf initialization macro. We're going to need some custom macros
for this project, so @code{AC_CONFIG_MACRO_DIR} tells Autoconf where
to find them. @code{AC_CONFIG_SRCDIR} is just a sanity check-- when
running @code{configure} users will sometimes pass an incorrect value
for @code{--srcdir}-- this macro equips the generated @code{configure}
script to catch that. @code{AC_CONFIG_AUX_DIR} tells Autoconf to place
auxilliary scripts (@code{missing} & @code{ionstall-sh}, e.g.) in a
sub-directory named @file{build-aux}.

@code{AC_CONFIG_HEADERS} tells Autoconf to generate a header file
named @file{config.h} containing C preprocessor @code{#define}s
for the project. Note that we need to generate a template file
@file{config.h.in} via @code{autoheader}.

Finally, we initialize Automake, libtool, check for a C++
compiler & produce Makefile templates.

The Autmake template for the root makefile is trivial:

@example
SUBDIRS = src
@end example

Let us begin the Makefile template in @file{src}:

@example
bin_PROGRAMS = az-tags
az_tags_SOURCES = main.cc
AM_CXXFLAGS = -std=c++17
@end example

We will need to perform some one-time setup:

@example
mkdir build-aux
touch NEWS README AUTHORS ChangeLog
autoheader
aclocal
autoconf
automake --add-missing
@end example

At this point, we can run @code{./configure}, but @code{make} will
fail miserably. Our program needs to be able to find @code{scribbu},
@code{openssl} and @code{boost} includes, along with the corresponding
libraries. All the required libraries other than @code{libscribbu}
provide pre-built macros which we can copy from the scribbu source
distro into @file{macros}. Let us add the following lines to
@file{configure.ac}, just before the call to @code{AC_CONFIG_FILES}:

@example
PKG_CHECK_MODULES([GUILE], [guile-2.2])
AX_BOOST_BASE([1.58], [], 
    [AC_MSG_ERROR([Scribbu requires boost_base 1.58 or later.])])
echo "Checkpoint 3: BOOST_LDFLAGS is $BOOST_LDFLAGS;" >&AS_MESSAGE_LOG_FD

AX_BOOST_IOSTREAMS
AX_BOOST_FILESYSTEM
AX_BOOST_SYSTEM
AX_CHECK_OPENSSL([],[AC_MSG_ERROR([Scribbu requires openssl.])])
@end example

Each of these will define Automake variables describing where we can
find headers & libraries which we can add to @file{src/Makefile.am},
which now reads:

@example
bin_PROGRAMS = az-tags
az_tags_SOURCES = main.cc
AM_CPPFLAGS = $(BOOST_CPPFLAGS)
AM_CXXFLAGS = -std=c++17 $(GUILE_CFLAGS)
AM_LDFLAGS = $(BOOST_LDFLAGS)
LDADD = $(GUILE_LIBS)           \
	$(BOOST_SYSTEM_LIB)     \
	$(BOOST_FILESYSTEM_LIB) \
	$(BOOST_IOSTREAMS_LIB)  \
	$(OPENSSL_LIBS)
@end example

This just leaves the question of where to find @code{libscribbu}. scribbu,
at the time of this writing, provides no Autoconf macros (however, this
sample provided the author the opportunity to prototype one).

We add the following code to @file{configure.ac}, just after the call
to @code{AC_PROG_CXX} (it's a lot of code; step-by-step explanation to
follow):

@example
AC_ARG_WITH([scribbu],
    AS_HELP_STRING([--with-scribbu=DIR], 
                   [root directory of scribbu installation]),
    [
        case "$withval" in
	"" | y | ye | yes | n | no)
	    AC_MSG_ERROR([--with-scribbu takes a root directory]);;
	*) 
	    scribbu_dirs="$withval";;
	esac
    ],
    [
        # Just use the defaults
	scribbu_dirs="/usr/local /usr /opt/local /sw"
    ])

dnl One way or another, we have one or more candidates in $@{scribbu_dirs@}
found=no
for scribbu_home in $@{scribbu_dirs@}; do
    AC_MSG_CHECKING([for scribbu/scribbu.h under $@{scribbu_home@}])
    if test -f "$@{scribbu_home@}/include/scribbu/scribbu.hh"; then
        SCRIBBU_INCLUDES="-I$@{scribbu_home@}/include/scribbu"
	SCRIBBU_LDFLAGS="-L$@{scribbu_home@}/lib"
	SCRIBBU_LIBS="-lscribbu"
	found=yes
	AC_MSG_RESULT([yes])
	break
    else
        AC_MSG_RESULT([no])
    fi
done

if test "$found" != "yes"; then
    AC_MSG_ERROR([couldn't find scribbu])
fi

# try the preprocessor and linker with our new flags,
# being careful not to pollute the global LIBS, LDFLAGS, and CPPFLAGS
AC_MSG_CHECKING([whether compiling and linking against scribbu will work])

save_LIBS="$LIBS"
save_LDFLAGS="$LDFLAGS"
save_CPPFLAGS="$CPPFLAGS"
LIBS="$SCRIBBU_LIBS $LIBS"
LDFLAGS="$SCRIBBU_LDFLAGS $LDFLAGS"
CPPFLAGS="$SCRIBBU_CPPFLAGS $CPPFLAGS"

AC_LANG_PUSH([C++])
AC_CHECK_HEADER([scribbu/scribbu.hh], [scribbu_hh=yes], [scribbu_hh=no])
# I'd like to do AC_CHECK_LIB here, but I can't link against libscribbu
# in a test because it, in turn depends on a bunch of other libs
AC_CHECK_FILE([$@{scribbu_home@}/lib/libscribbu.la],
    [scribbu_la=yes], [scribbu_la=no])
AC_LANG_POP([C++])

LIBS="$save_LIBS"
LDFLAGS="$save_LDFLAGS"
CPPFLAGS="$save_CPPFLAGS"

if test "yes" = "$scribbu_hh" && test "yes" = "$scribbu_la"; then
    AC_DEFINE([HAVE_SCRIBBU], [1], [Define to 1 if you have libscribbu])
else
    AC_MSG_ERROR([az-tags requires scribbu])
fi

AC_SUBST([SCRIBBU_CPPFLAGS])
AC_SUBST([SCRIBBU_LIBS])
AC_SUBST([SCRIBBU_LDFLAGS])
@end example

The first step is to locate @code{libscribbu}. We will form the
variable @code{scribbu_dirs} containing one or more directories to
check. Now, the user could always just tell us where it is. That is
the reason we begin with @code{AC_ARG_WITH}: if the user invokes
@code{configure} with @code{--with-scribbu=...} we will just use
that. Otherwise, we will examine a default set of locations.

That's what the for look does; for each location in
@code{scribbu_dirs}, it checks for @file{scribbu.hh} in a
sub-directory named @file{include/scribbu} of the current location. On
success, we set a few variables recording that result & break. If we
check all locations without success, then we fail.

Now, just because we found a header file at a given place doesn't mean
we can biuld against it or its associated library. The typical idiom
is to execute the macros @code{AC_CHECK_HEADER} and
@code{AC_CHECK_LIB} to make sure we can include the header and link
against the library, respectively.

The problem in my case is that @code{AC_CHECK_LIB} will fail, not
through any fault of @code{libscribbu}, but because it depends on a
number of other libraries; the test will fail with unresolved
externals & I can't see how to add the relevant link flags in the macro.
Instead, I settle for @code{AC_CHECK_FILE}.

If both these pass, we know we're good to go; the question remains: how
to record the information we've just discovered?  The Autoconf manual
states that one should never add options to user variables such as
@code{CPPFLAGS}. The idiom seems to be to define new variables that
the Automake author can add to their rules. In this case, create
three new variables:

@enumerate

@item
@code{SCRIBBU_CPPFLAGS} to hold the @code{-I} option that will enable
the build to find the @code{libscribbu} headers

@item
@code{SCRIBBU_LIBS} to hold the the @code{-L} options that will
enable the build to link against @code{libscribbu}

@item
@code{SCRIBBU_LDLAGS} to hold any linker required flags 

@end enumerate

This lets us augment @file{src/Makefile.am} to:

@example
bin_PROGRAMS = az-tags
az_tags_SOURCES = main.cc
AM_CPPFLAGS = $(BOOST_CPPFLAGS) $(SCRIBBU_CPPFLAGS)
AM_CXXFLAGS = -std=c++17 $(GUILE_CFLAGS)
AM_LDFLAGS = $(SCRIBBU_LDFLAGS) $(BOOST_LDFLAGS)
LDADD = $(SCRIBBU_LIBS)         \
        $(GUILE_LIBS)           \
	$(BOOST_SYSTEM_LIB)     \
	$(BOOST_FILESYSTEM_LIB) \
	$(BOOST_IOSTREAMS_LIB)  \
	$(OPENSSL_LIBS)
@end example

With that, we can @code{configure}:

@example
$>: autoreconf -vfi
autoreconf: Entering directory `.'
autoreconf: configure.ac: not using Gettext
autoreconf: running: aclocal --force
...
$>: ./configure --prefix=$HOME
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a thread-safe mkdir -p... /bin/mkdir -p
...
config.status: creating Makefile
config.status: creating src/Makefile
config.status: creating config.h
config.status: executing depfiles commands
config.status: executing libtool commands
$>: make
make  all-recursive
make[1]: Entering directory '/tmp/az-tags'
Making all in src
make[2]: Entering directory '/tmp/az-tags/src'
g++ -DHAVE_CONFIG_H -I. -I/home/mgh/doc/code/projects/az-tags/src -I..  -I/usr/include   -std=c++17 -pthread -I/usr/local/include/guile/2.2 -g -O2 -MT main.o -MD -MP -MF .deps/main.Tpo -c -o main.o /home/mgh/doc/code/projects/az-tags/src/main.cc
...
@end example

We have a build! Let us take a look at a file downloaded from Amazon.com:

@example
$>: scribbu dump lorca.mp3
"lorca.mp3":
ID3v2.3(.0) Tag:
452951 bytes, synchronised
...
COMM (<no description>):
Amazon.com Song ID: 203558254
...
9425708 bytes of track data:
MD5: 48ff9cadea7d842e9059db25159d2daa
ID3v1.1: The Pogues - Lorca's Novena
Hell's Ditch [Expanded] (US Ve (track 5), 1990
Amazon.com Song ID: 20355825
unknown genre 255

$>: src/az-tags lorca.mp3
lorca.mp3 has 1 ID3v2 tags, and an ID3v1 tag
updating the comment frame containing Amazon.com Song ID: 203558254
all tags processed; emplacing new tagset...
emplacing new tagset...done.
clearing ID3v1 comment
$>: scribbu dump lorca.mp3
"lorca.mp3":
ID3v2.3(.0) Tag:
452951 bytes, synchronised
...
COMM (amazon.com song id):
Amazon.com Song ID: 203558254
...
9425708 bytes of track data:
MD5: 48ff9cadea7d842e9059db25159d2daa
ID3v1.1: The Pogues - Lorca's Novena
Hell's Ditch [Expanded] (US Ve (track 5), 1990

unknown genre 255
@end example


@node Frame Identifiers
@unnumbered Frame Identifiers

@multitable {'original-release-year-frame} {xxx} {xxxx}
@headitem Symbol @tab 2.3 @tab 2.4+
@item 'album-frame @tab TAL @tab TALB
@item 'artist-frame @tab TP1 @tab TPE1
@item 'band-frame @tab TP2 @tab TPE2 
@item 'bpm-frame @tab TBP @tab TBPM 
@item 'comment-frame @tab COM @tab COMM
@item 'composer-frame @tab TCM @tab TCOM 
@item 'conductor-frame @tab TP3 @tab TPE3 
@item 'content-group-frame @tab TT1 @tab TIT1 
@item 'copyright-frame @tab TCR @tab TCOP 
@item 'date-frame @tab TDA @tab TDAT 
@item 'encoded-by-frame @tab TEN @tab TENC
@item 'file-owner-frame @tab N/A @tab TOWN     
@item 'file-type-frame @tab TFT @tab TFLT 
@item 'genre-frame @tab TCO @tab TCON
@item 'initial-key-frame @tab TKE @tab TKEY 
@item 'interpreted-by-frame @tab TP4 @tab TPE4 
@item 'isrc-frame @tab TRC @tab TSRC 
@item 'langs-frame @tab TLA @tab TLAN
@item 'length-frame @tab TLE @tab TLEN 
@item 'lyricist-frame @tab TXT @tab TEXT 
@item 'media-type-frame @tab TMT @tab TMED 
@item 'original-album-frame @tab TOT @tab TOAL 
@item 'original-artist-frame @tab TOA @tab TOPE 
@item 'original-filename-frame @tab TOF @tab TOFN 
@item 'original-lyricist-frame @tab TOL @tab TOLY 
@item 'original-release-year-frame @tab TOR @tab TORY 
@item 'part-of-a-set-frame @tab TPA @tab TPOS 
@item 'play-count-frame @tab CNT @tab PCNT
@item 'playlist-delay-frame @tab TDY @tab TDLY 
@item 'pop-frame @tab POP @tab POPM
@item 'publisher-frame @tab TPB @tab TPUB 
@item 'recording-dates-frame @tab TRD @tab TRDA 
@item 'settings-frame @tab TSS @tab TSSE
@item 'size-frame @tab TSI @tab TSIZ 
@item 'station-name-frame @tab N/A @tab TRSN     
@item 'station-owner-frame @tab N/A @tab TRSO     
@item 'subtitle-frame @tab TT3 @tab TIT3 
@item 'tag-cloud-frame @tab XTG @tab XTAG
@item 'time-frame @tab TIM @tab TIME 
@item 'title-frame @tab TT2 @tab TIT2
@item 'track-frame @tab TRK @tab TRCK
@item 'udt-frame @tab TXX @tab TXXX
@item 'year-frame @tab TYE @tab TYER
@end multitable

@node Character Encodings
@unnumbered Character Encodings

@code{scribbu} uses @code{iconv} for character encoding. For
convenience, here is the list of identifiers used to name them:

@enumerate

@item European & Russian languages

@verb{.ASCII.}, @verb{.ISO_8859_1.}, @verb{.ISO_8859_2.},
@verb{.ISO_8859_3.}, @verb{.ISO_8859_4.}, @verb{.ISO_8859_5.},
@verb{.ISO_8859_7.}, @verb{.ISO_8859_9.}, @verb{.ISO_8859_10.},
@verb{.ISO_8859_13.}, @verb{.ISO_8859_14.}, @verb{.ISO_8859_15.},
@verb{.ISO_8859_16.}, @verb{.KOI8_R.}, @verb{.KOI8_U.},
@verb{.KOI8_RU.}, @verb{.CP1250.}, @verb{.CP1251.}, @verb{.CP1252.},
@verb{.CP1253.}, @verb{.CP1254.}, @verb{.CP1257.}, @verb{.CP850.},
@verb{.CP866.}, @verb{.CP1131.}, @verb{.MacRoman.},
@verb{.MacCentralEurope.}, @verb{.MacIceland.}, @verb{.MacCroatian.},
@verb{.MacRomania.}, @verb{.MacCyrillic.}, @verb{.MacUkraine.},
@verb{.MacGreek.}, @verb{.MacTurkish.}, @verb{.Macintosh.}

@item Semitic languages
@verb{.ISO_8859_6.}, @verb{.ISO_8859_8.}, @verb{.CP1255.},
@verb{.CP1256.}, @verb{.CP862.}, @verb{.MacHebrew.},
@verb{.MacArabic.}

@item Japanese
@verb{.EUC_JP.}, @verb{.SHIFT_JIS.}, @verb{.CP932.},
@verb{.ISO_2022_JP.}, @verb{.ISO_2022_JP_2.}, @verb{.ISO_2022_JP_1.},
@verb{.ISO_2022_JP_MS.}

@item Chinese
@verb{.EUC_CN.}, @verb{.HZ.}, @verb{.GBK.}, @verb{.CP936.},
@verb{.GB18030.}, @verb{.EUC_TW.}, @verb{.BIG5.}, @verb{.CP950.},
@verb{.BIG5_HKSCS.}, @verb{.BIG5_HKSCS_2004.},
@verb{.BIG5_HKSCS_2001.}, @verb{.BIG5_HKSCS_1999.},
@verb{.ISO_2022_CN.}, @verb{.ISO_2022_CN_EXT.}

@item Korean
@verb{.EUC_KR.}, @verb{.CP949.}, @verb{.ISO_2022_KR.}, @verb{.JOHAB.}

@item Armenian
@verb{.ARMSCII_8.}

@item Georgian
@verb{.Georgian_Academy.}, @verb{.Georgian_PS.}

@item Tajik
@verb{.KOI8_T.}

@item Kazakh
@verb{.PT154.}, @verb{.RK1048.}

@item Thai
@verb{.TIS_620.}, @verb{.CP874.}, @verb{.MacThai.}

@item Laotian
@verb{.MuleLao_1.}, @verb{.CP1133.}

@item Vietnamese
@verb{.VISCII.}, @verb{.TCVN.}, @verb{.CP1258.}

@item Platform specifics
@verb{.HP_ROMAN8.}, @verb{.NEXTSTEP.}

@item Full Unicode
@verb{.UTF_8.}, @verb{.UCS_2.}, @verb{.UCS_2BE.}, @verb{.UCS_2LE.},
@verb{.UCS_4.}, @verb{.UCS_4BE.}, @verb{.UCS_4LE.}, @verb{.UTF_16.},
@verb{.UTF_16BE.}, @verb{.UTF_16LE.}, @verb{.UTF_32.},
@verb{.UTF_32BE.}, @verb{.UTF_32LE.}, @verb{.UTF_7.}, @verb{.C99.},
@verb{.JAVA.}

@end enumerate

@node Index
@unnumbered Index

@printindex cp

@bye

@c scribbu.texi ends here
